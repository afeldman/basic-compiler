-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.6.1).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -Wno-incomplete-patterns -Wno-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Basic.Par
  ( happyError
  , myLexer
  , pBasic
  , pListLine
  , pLine
  , pStm
  , pExp
  , pOp
  , pUOp
  ) where

import Prelude

import qualified Basic.Abs
import Basic.Lex

}

%name pBasic Basic
%name pListLine ListLine
%name pLine Line
%name pStm Stm
%name pExp Exp
%name pOp Op
%name pUOp UOp
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!'      { PT _ (TS _ 1)  }
  '%'      { PT _ (TS _ 2)  }
  '&'      { PT _ (TS _ 3)  }
  '('      { PT _ (TS _ 4)  }
  ')'      { PT _ (TS _ 5)  }
  '*'      { PT _ (TS _ 6)  }
  '+'      { PT _ (TS _ 7)  }
  '-'      { PT _ (TS _ 8)  }
  '/'      { PT _ (TS _ 9)  }
  '<'      { PT _ (TS _ 10) }
  '<='     { PT _ (TS _ 11) }
  '<>'     { PT _ (TS _ 12) }
  '='      { PT _ (TS _ 13) }
  '>'      { PT _ (TS _ 14) }
  '>='     { PT _ (TS _ 15) }
  'ELSE'   { PT _ (TS _ 16) }
  'END'    { PT _ (TS _ 17) }
  'FOR'    { PT _ (TS _ 18) }
  'GOTO'   { PT _ (TS _ 19) }
  'IF'     { PT _ (TS _ 20) }
  'INPUT'  { PT _ (TS _ 21) }
  'LET'    { PT _ (TS _ 22) }
  'NEXT'   { PT _ (TS _ 23) }
  'PRINT'  { PT _ (TS _ 24) }
  'REM'    { PT _ (TS _ 25) }
  'STEP'   { PT _ (TS _ 26) }
  'THEN'   { PT _ (TS _ 27) }
  'TO'     { PT _ (TS _ 28) }
  '|'      { PT _ (TS _ 29) }
  L_Ident  { PT _ (TV $$)   }
  L_integ  { PT _ (TI $$)   }
  L_quoted { PT _ (TL $$)   }

%%

Ident :: { Basic.Abs.Ident }
Ident  : L_Ident { Basic.Abs.Ident $1 }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

Basic :: { Basic.Abs.Basic }
Basic : ListLine { Basic.Abs.BasicGr $1 }

ListLine :: { [Basic.Abs.Line] }
ListLine : Line { (:[]) $1 } | Line ListLine { (:) $1 $2 }

Line :: { Basic.Abs.Line }
Line : Integer Stm { Basic.Abs.LBasic $1 $2 }

Stm :: { Basic.Abs.Stm }
Stm
  : 'REM' String { Basic.Abs.SRem $2 }
  | 'GOTO' Integer { Basic.Abs.SGoTo $2 }
  | 'LET' Ident '=' Exp { Basic.Abs.SLet $2 $4 }
  | 'PRINT' Exp { Basic.Abs.SPrint $2 }
  | 'INPUT' Ident { Basic.Abs.SInput $2 }
  | 'IF' Ident '=' Exp 'THEN' Exp { Basic.Abs.SIfStm $2 $4 $6 }
  | 'IF' Ident '=' Exp 'THEN' Exp 'ELSE' Exp { Basic.Abs.SIfElse $2 $4 $6 $8 }
  | 'FOR' Ident '=' Exp 'TO' Exp { Basic.Abs.SFORStm $2 $4 $6 }
  | 'FOR' Ident '=' Exp 'TO' Exp 'STEP' Integer { Basic.Abs.SFORStmS $2 $4 $6 $8 }
  | 'NEXT' Ident { Basic.Abs.SNext $2 }
  | 'END' { Basic.Abs.SEnd }

Exp :: { Basic.Abs.Exp }
Exp
  : UOp Exp { Basic.Abs.EUOperation $1 $2 }
  | Exp Op Exp { Basic.Abs.EOperation $1 $2 $3 }
  | '(' Exp ')' { Basic.Abs.EBreace $2 }
  | Integer { Basic.Abs.EInt $1 }
  | String { Basic.Abs.EString $1 }
  | Ident { Basic.Abs.EIdent $1 }

Op :: { Basic.Abs.Op }
Op
  : '+' { Basic.Abs.OPlus }
  | '-' { Basic.Abs.OMinus }
  | '*' { Basic.Abs.OMult }
  | '/' { Basic.Abs.ODiv }
  | '%' { Basic.Abs.OMod }
  | '=' { Basic.Abs.OEq }
  | '<' { Basic.Abs.OLt }
  | '<=' { Basic.Abs.OLtEq }
  | '>' { Basic.Abs.OGt }
  | '>=' { Basic.Abs.OGtEq }
  | '<>' { Basic.Abs.ONEq }
  | '&' { Basic.Abs.OAnd }
  | '|' { Basic.Abs.OOr }

UOp :: { Basic.Abs.UOp }
UOp : '-' { Basic.Abs.UOMinus } | '!' { Basic.Abs.UONot }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

